.\" Automatically generated by Pandoc 2.5
.\"
.TH "PMEMOBJ_MEMCPY_PERSIST" "3" "2019-11-29" "PMDK - pmemobj API version 2.3" "PMDK Programmer's Manual"
.hy
.\" Copyright 2017-2018, Intel Corporation
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\"     * Redistributions of source code must retain the above copyright
.\"       notice, this list of conditions and the following disclaimer.
.\"
.\"     * Redistributions in binary form must reproduce the above copyright
.\"       notice, this list of conditions and the following disclaimer in
.\"       the documentation and/or other materials provided with the
.\"       distribution.
.\"
.\"     * Neither the name of the copyright holder nor the names of its
.\"       contributors may be used to endorse or promote products derived
.\"       from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.\" "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.\" LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.\" A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
.\" OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
.\" OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.SH NAME
.PP
\f[B]pmemobj_persist\f[R](), \f[B]pmemobj_xpersist\f[R](),
\f[B]pmemobj_flush\f[R](), \f[B]pmemobj_xflush\f[R](),
\f[B]pmemobj_drain\f[R](), \f[B]pmemobj_memcpy\f[R](),
\f[B]pmemobj_memmove\f[R](), \f[B]pmemobj_memset\f[R](),
\f[B]pmemobj_memcpy_persist\f[R](), \f[B]pmemobj_memset_persist\f[R]()
\- low\-level memory manipulation functions
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <libpmemobj.h>

void pmemobj_persist(PMEMobjpool *pop, const void *addr,
    size_t len);
void pmemobj_flush(PMEMobjpool *pop, const void *addr,
    size_t len);
void pmemobj_drain(PMEMobjpool *pop);

int pmemobj_xpersist(PMEMobjpool *pop, const void *addr,
    size_t len, unsigned flags);
int pmemobj_xflush(PMEMobjpool *pop, const void *addr,
    size_t len, unsigned flags);

void *pmemobj_memcpy(PMEMobjpool *pop, void *dest,
    const void *src, size_t len, unsigned flags);
void *pmemobj_memmove(PMEMobjpool *pop, void *dest,
    const void *src, size_t len, unsigned flags);
void *pmemobj_memset(PMEMobjpool *pop, void *dest,
    int c, size_t len, unsigned flags);

void *pmemobj_memcpy_persist(PMEMobjpool *pop, void *dest,
    const void *src, size_t len);
void *pmemobj_memset_persist(PMEMobjpool *pop, void *dest,
    int c, size_t len);
\f[R]
.fi
.SH DESCRIPTION
.PP
The \f[B]libpmemobj\f[R]\-specific low\-level memory manipulation
functions described here leverage the knowledge of the additional
configuration options available for \f[B]libpmemobj\f[R](7) pools, such
as replication.
They also take advantage of the type of storage behind the pool and use
appropriate flush/drain functions.
It is advised to use these functions in conjunction with
\f[B]libpmemobj\f[R](7) objects rather than using low\-level memory
manipulation functions from \f[B]libpmem\f[R].
.PP
\f[B]pmemobj_persist\f[R]() forces any changes in the range
[\f[I]addr\f[R], \f[I]addr\f[R]+\f[I]len\f[R]) to be stored durably in
persistent memory.
Internally this may call either \f[B]pmem_msync\f[R](3) or
\f[B]pmem_persist\f[R](3).
There are no alignment restrictions on the range described by
\f[I]addr\f[R] and \f[I]len\f[R], but \f[B]pmemobj_persist\f[R]() may
expand the range as necessary to meet platform alignment requirements.
.RS
.PP
WARNING: Like \f[B]msync\f[R](2), there is nothing atomic or
transactional about this call.
Any unwritten stores in the given range will be written, but some stores
may have already been written by virtue of normal cache
eviction/replacement policies.
Correctly written code must not depend on stores waiting until
\f[B]pmemobj_persist\f[R]() is called to become persistent \- they can
become persistent at any time before \f[B]pmemobj_persist\f[R]() is
called.
.RE
.PP
The \f[B]pmemobj_flush\f[R]() and \f[B]pmemobj_drain\f[R]() functions
provide partial versions of the \f[B]pmemobj_persist\f[R]() function
described above.
These functions allow advanced programs to create their own variations
of \f[B]pmemobj_persist\f[R]().
For example, a program that needs to flush several discontiguous ranges
can call \f[B]pmemobj_flush\f[R]() for each range and then follow up by
calling \f[B]pmemobj_drain\f[R]() once.
For more information on partial flushing operations, see
\f[B]pmem_flush\f[R](3).
.PP
\f[B]pmemobj_xpersist\f[R]() is a version of \f[B]pmemobj_persist\f[R]()
function with additional \f[I]flags\f[R] argument.
It supports only the \f[B]PMEMOBJ_F_RELAXED\f[R] flag.
This flag indicates that memory transfer operation does not require
8\-byte atomicity guarantees.
.PP
\f[B]pmemobj_xflush\f[R]() is a version of \f[B]pmemobj_flush\f[R]()
function with additional \f[I]flags\f[R] argument.
It supports only the \f[B]PMEMOBJ_F_RELAXED\f[R] flag.
.PP
The \f[B]pmemobj_memmove\f[R](), \f[B]pmemobj_memcpy\f[R]() and
\f[B]pmemobj_memset\f[R]() functions provide the same memory copying as
their namesakes \f[B]memmove\f[R](3), \f[B]memcpy\f[R](3), and
\f[B]memset\f[R](3), and ensure that the result has been flushed to
persistence before returning (unless \f[B]PMEMOBJ_MEM_NOFLUSH\f[R] flag
was used).
Valid flags for those functions:
.IP \[bu] 2
\f[B]PMEMOBJ_F_RELAXED\f[R] \- This flag indicates that memory transfer
operation does not require 8\-byte atomicity guarantees.
.IP \[bu] 2
\f[B]PMEMOBJ_F_MEM_NOFLUSH\f[R] \- Don\[cq]t flush anything.
This implies \f[B]PMEMOBJ_F_MEM_NODRAIN\f[R].
Using this flag only makes sense when it\[cq]s followed by any function
that flushes data.
.PP
The remaining flags say \f[I]how\f[R] the operation should be done, and
are merely hints.
.IP \[bu] 2
\f[B]PMEMOBJ_F_MEM_NONTEMPORAL\f[R] \- Use non\-temporal instructions.
This flag is mutually exclusive with \f[B]PMEMOBJ_F_MEM_TEMPORAL\f[R].
On x86_64 this flag is mutually exclusive with
\f[B]PMEMOBJ_F_MEM_NOFLUSH\f[R].
.IP \[bu] 2
\f[B]PMEMOBJ_F_MEM_TEMPORAL\f[R] \- Use temporal instructions.
This flag is mutually exclusive with
\f[B]PMEMOBJ_F_MEM_NONTEMPORAL\f[R].
.IP \[bu] 2
\f[B]PMEMOBJ_F_MEM_WC\f[R] \- Use write combining mode.
This flag is mutually exclusive with \f[B]PMEMOBJ_F_MEM_WB\f[R].
On x86_64 this is an alias for \f[B]PMEMOBJ_F_MEM_NONTEMPORAL\f[R].
On x86_64 this flag is mutually exclusive with
\f[B]PMEMOBJ_F_MEM_NOFLUSH\f[R].
.IP \[bu] 2
\f[B]PMEMOBJ_F_MEM_WB\f[R] \- Use write back mode.
This flag is mutually exclusive with \f[B]PMEMOBJ_F_MEM_WC\f[R].
On x86_64 this is an alias for \f[B]PMEMOBJ_F_MEM_TEMPORAL\f[R].
.PP
\f[B]pmemobj_memcpy_persist\f[R]() is an alias for
\f[B]pmemobj_memcpy\f[R]() with flags equal to 0.
.PP
\f[B]pmemobj_memset_persist\f[R]() is an alias for
\f[B]pmemobj_memset\f[R]() with flags equal to 0.
.SH RETURN VALUE
.PP
\f[B]pmemobj_memmove\f[R](), \f[B]pmemobj_memcpy\f[R](),
\f[B]pmemobj_memset\f[R](), \f[B]pmemobj_memcpy_persist\f[R]() and
\f[B]pmemobj_memset_persist\f[R]() return destination buffer.
.PP
\f[B]pmemobj_persist\f[R](), \f[B]pmemobj_flush\f[R]() and
\f[B]pmemobj_drain\f[R]() do not return any value.
.PP
\f[B]pmemobj_xpersist\f[R]() and \f[B]pmemobj_xflush\f[R]() returns
non\-zero value and sets errno to EINVAL only if not supported flags has
been provided.
.SH EXAMPLES
.PP
The following code is functionally equivalent to
\f[B]pmemobj_memcpy_persist\f[R]():
.IP
.nf
\f[C]
void *
pmemobj_memcpy_persist(PMEMobjpool *pop, void *dest,
    const void *src, size_t len)
{
    void *retval = memcpy(dest, src, len);

    pmemobj_persist(pop, dest, len);

    return retval;
}
\f[R]
.fi
.PP
\f[B]pmemobj_persist\f[R]() can be thought of as this:
.IP
.nf
\f[C]
void
pmemobj_persist(PMEMobjpool *pop, const void *addr, size_t len)
{
    /* flush the processor caches */
    pmemobj_flush(pop, addr, len);

    /* wait for any pmem stores to drain from HW buffers */
    pmemobj_drain(pop);
}
\f[R]
.fi
.SH SEE ALSO
.PP
\f[B]memcpy\f[R](3), \f[B]memset\f[R](3), \f[B]pmem_msync\f[R](3),
\f[B]pmem_persist\f[R](3), \f[B]libpmem\f[R](7) \f[B]libpmemobj\f[R](7)
and \f[B]<http://pmem.io>\f[R]
